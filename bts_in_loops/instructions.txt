# ğŸ§  Python Iteration Behind the Scenes (BTS) â€“ Conceptual Flow

ğŸ“ 1. Iteration Tools (What we use to loop)
   - for loop
   - list/dictionary/set comprehensions
   - while loop with manual iterators
   - generator expressions
   ğŸ”„ These tools require something to **iterate over** â€” they look for iterable objects.

ğŸ“ 2. Iterable Objects (What we loop over)
   - Examples: lists, tuples, strings, dictionaries, sets, file objects
   - Internally, they implement the `__iter__()` method
     âœ This method returns an **iterator object**

ğŸ“ 3. Iterator (The worker behind the loop)
   - This is the object that does the actual work of remembering position
   - Has:
     âœ… `__iter__()` â†’ returns itself
     âœ… `__next__()` â†’ returns next item or raises `StopIteration`

ğŸ“ 4. The Flow (BTS of a `for` loop):

   for item in iterable:
       # Do something

ğŸ”½ Internally executes like:

   iterator = iter(iterable)       # calls iterable.__iter__()
   while True:
       try:
           item = next(iterator)   # calls iterator.__next__()
           # Do something with item
       except StopIteration:
           break

ğŸ“ 5. Important Notes:
   - `iter()` returns an iterator from an iterable
   - `next()` fetches the next value from an iterator
   - `StopIteration` tells Python when to stop looping

ğŸ“ 6. Bonus: Files are iterators
   - File objects implement both `__iter__()` and `__next__()`
   - So you can directly do:

     with open("file.txt") as f:
         for line in f:
             print(line)

ğŸ“ 7. Visual Summary Flow:
   
   Iteration Tool
       â†“
   Iterable Object (e.g. list, file)
       â†“
   Calls â†’ __iter__()
       â†“
   Returns Iterator Object
       â†“
   Calls â†’ __next__()
       â†“
   Gets Next Item
       â†“
   Continues Until â†’ StopIteration



# ---------------------------------------------
# ğŸ“˜ Topic: Behind the Scenes (BTS) in Python Loops
# ---------------------------------------------

# ğŸ¯ Main Objective:
# Understand what happens *behind the scenes* (BTS) when we use `for` loops in Python.
# Learn how `iter()` and `next()` work to support loop iteration.

# âœ… Basic Definitions:

# Iterable:
# Any object in Python capable of returning its members one at a time.
# Examples: list, tuple, string, dictionary, set, etc.

# Iterator:
# An object that remembers the current position and produces the next value when asked (via `next()`).

# ğŸ” BTS of a for-loop:
# Example:
myList = [10, 20, 30]

for item in myList:
    print(item)

# ğŸ‘‰ What actually happens behind the scenes:
# Step 1: Python calls iter(myList) to get an iterator object
# Step 2: It repeatedly calls next(iterator) until StopIteration is raised

# Here's the equivalent code:
iterator = iter(myList)
while True:
    try:
        item = next(iterator)
        print(item)
    except StopIteration:
        break

# ğŸ§  Important Concepts:

# 1. iter() returns a new iterator object
#    It does not return the original list â€” they are different objects.

myNewList = [1, 2, 3]
print(iter(myNewList) is myNewList)  # False

# Because: myNewList is a list, and iter(myNewList) is a list_iterator object

# You can check types:
print(type(myNewList))         # <class 'list'>
print(type(iter(myNewList)))   # <class 'list_iterator'>

# 2. next() gives the next value in the sequence from an iterator:
itr = iter(myNewList)
print(next(itr))  # 1
print(next(itr))  # 2
print(next(itr))  # 3
# print(next(itr))  # Raises StopIteration

# ğŸ” Key Difference:
# - Iterable: Can be looped over (but does not remember state)
# - Iterator: Can be looped using `next()` and *remembers* its position

# âœ… Check if object is Iterable or Iterator
from collections.abc import Iterable, Iterator

print(isinstance(myNewList, Iterable))  # True
print(isinstance(myNewList, Iterator))  # False

print(isinstance(iter(myNewList), Iterator))  # True

# ------------------------------
# ğŸ“š Real-world Analogy:
# - Iterable: A playlist (you can start from beginning any time)
# - Iterator: A music player playing that playlist â€” it remembers the current song
# ------------------------------

# ğŸ§ª Bonus: Creating Custom Iterators
class CountUpto:
    def __init__(self, max):
        self.max = max
        self.current = 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.current > self.max:
            raise StopIteration
        val = self.current
        self.current += 1
        return val

counter = CountUpto(3)
for num in counter:
    print(num)  # Output: 1 2 3

# ---------------------------------------------
# ğŸ”‘ Summary:
# - `for` loop in Python uses `iter()` and `next()` under the hood.
# - `iter(iterable)` creates a new iterator object.
# - `next(iterator)` fetches the next item.
# - When the iterator is exhausted, it raises `StopIteration`.
# - Lists, strings, etc., are iterable â€” but not iterators themselves.
# - This BTS logic helps you write custom iterators using `__iter__` and `__next__`.

# ğŸš€ Practice Tip:
# Try writing custom iterators or manually replicate loop logic using iter() and next().

# ğŸ’¬ Test Yourself:
# 1. What does `iter()` return?
# 2. Why is `iter(myList) is myList` False?
# 3. What will happen if we keep calling `next()` after the iterator is exhausted?
# 4. How does Python know when to stop in a `for` loop?
